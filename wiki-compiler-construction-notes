http://en.wikipedia.org/wiki/Book:Compiler_construction

### 0 Intro

So, we're dealing with syntax, how we use characters to represent an 'element',
grammar, the ways in which we are allowed to combine elements to make valid
combinations, and semantics, the expression of what we want to achieve,
using the combination of the aforementions elements.

### 1 Compiler

A compiler simple converts one language to another.  It determines the
correctness of the syntax, generates correct and efficient object code,
performs run-time organisation and formats the output according to assembler
and/or linker conventions--whatever all that exactly means.

It's divided up into the front, middle and back end.

Front: It performs code substitutions, macros in C, for example.  This is
called preprocessing.  It breaks up the source code into small 'tokens',
such as keywords and variables.  This is called lexical analysis.  Using the
language's grammar, the tokens are manipulated into a 'parse tree' a repre-
sentation of the program's instructions.  It then checks the parse tree
for type errors, associates variables and functions to their defintions
(generating the symbol table?), rejecting incorrect assignments.  This is
called semantic analysis.  It produces, all being well, intermediate object
code: a intermediate representation (IR) of the source code.

Middle/Back:  This section takes the IR of the front end, and analyses it,
often using "data flow analysis."  The IR is then optimised: removes uselss
code, propogation of constant values, takes calculations out of loops. This
also creates IR code.  That IR code is then translated into the target
language: code generation.  It choses the right "target instruction" for
each IR instruction. Registers in the CPU are chosen, etc.


